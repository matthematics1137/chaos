<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Logistic Map — Cobweb & Bifurcation</title>
    <style>
        :root {
            --bg: #f5f5f5;
            --fg: #222;
            --muted: #555;
            --accent: #0366d6;
        }
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 2rem; background: var(--bg); color: var(--fg); }
        h1 { text-align: center; color: #333; margin-bottom: .25rem; }
        p { color: #444; line-height: 1.6; }
        .layout { display: grid; grid-template-areas: 'top' 'main' 'bottom'; gap: 16px; }
        .main { grid-area: main; }
        .note-bubble { background: #fff8dc; border: 1px solid #f0e6b6; border-radius: 8px; padding: 10px; color: #5b4b20; }
        .note-top { grid-area: top; }
        .note-bottom { grid-area: bottom; }
        .note-left { grid-area: left; }
        .note-right { grid-area: right; }
        @media(min-width: 1100px){
            .layout { grid-template-columns: 260px 1fr 260px; grid-template-areas: 'top top top' 'left main right' 'bottom bottom bottom'; }
        }
        .row { display: grid; grid-template-columns: 1fr; gap: 18px; }
        .panel { background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.04); }
        .controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 10px; }
        label { font-size: .9rem; color: var(--muted); }
        input[type="range"] { width: 220px; }
        input[type="number"] { width: 90px; }
        .button { background: var(--accent); border: none; color: white; padding: 8px 12px; border-radius: 6px; font-weight: bold; cursor: pointer; }
        .button.secondary { background: #6b7280; }
        canvas { width: 100%; height: auto; background: #fff; border: 1px solid #ddd; border-radius: 6px; image-rendering: pixelated; }
        .caption { font-size: .9rem; color: var(--muted); margin-top: 6px; }
        .back { display: inline-block; margin-top: 18px; color: var(--accent); text-decoration: none; font-weight: bold; }
        @media(min-width: 1000px){ .row { grid-template-columns: 1fr; } }
        .tabs { display:flex; gap:8px; margin: 8px 0 8px; }
        .tabbtn { background:#e5e7eb; border:none; padding:8px 12px; border-radius:9999px; cursor:pointer; font-weight:bold; color:#374151; }
        .tabbtn.active { background:#0366d6; color:#fff; }
        .tabview { display:none; }
        .tabview.active { display:block; }
    </style>
</head>
<body>
    <h1>Logistic Map</h1>
    <p>
        The logistic map, x<sub>n+1</sub> = r x<sub>n</sub> (1 − x<sub>n</sub>), is a canonical example from
        Strogatz’s <em>Nonlinear Dynamics and Chaos</em> showing period-doubling and the
        onset of chaos. Tweak the parameter r and initial condition x₀ to see the
        cobweb iterates and how long-term behavior changes.
    </p>

    <div class="layout">
        <div class="note-bubble note-top">Top notes area — author explanations.</div>

        <div class="note-bubble note-left">Side notes — definitions, parameter hints, references.</div>

        <div class="main">
        <div class="tabs">
            <button class="tabbtn active" data-target="panel-cobweb">Cobweb</button>
            <button class="tabbtn" data-target="panel-bif">Bifurcation</button>
            <button class="tabbtn" data-target="panel-lyap">Lyapunov</button>
        </div>
        <div class="row">
            <div class="panel tabview active" id="panel-cobweb">
                <h3 style="margin:6px 0 8px 0">Cobweb Diagram</h3>
                <div class="controls">
                    <label>r: <input id="r" type="range" min="2.5" max="4" step="0.001" value="3.5" /> <input id="rNum" type="number" min="2.5" max="4" step="0.001" value="3.5"/></label>
                    <label>x₀: <input id="x0" type="range" min="0" max="1" step="0.001" value="0.2" /> <input id="x0Num" type="number" min="0" max="1" step="0.001" value="0.2"/></label>
                    <label>Iter: <input id="iters" type="number" min="1" max="1000" step="1" value="60" /></label>
                    <button class="button" id="randomize">Randomize x₀</button>
                    <button class="button secondary" id="clearCobweb">Clear</button>
                </div>
            <canvas id="cobweb" width="700" height="700"></canvas>
            <div class="caption">Unit square with y = rx(1 − x) and y = x. Cobweb shows successive iterates.</div>
            </div>

            <div class="panel tabview" id="panel-bif">
                <h3 style="margin:6px 0 8px 0">Bifurcation Diagram</h3>
                <div class="controls">
                    <label>r min: <input id="rMin" type="number" min="2.5" max="4" step="0.001" value="2.5" /></label>
                    <label>r max: <input id="rMax" type="number" min="2.5" max="4" step="0.001" value="4" /></label>
                    <label>Samples: <input id="samples" type="number" min="200" max="4000" step="50" value="1000" /></label>
                    <label>Skip: <input id="skip" type="number" min="50" max="5000" step="50" value="300" /></label>
                    <label>Plot: <input id="plotN" type="number" min="50" max="4000" step="50" value="300" /></label>
                    <label>y min: <input id="yMin" type="number" min="0" max="1" step="0.001" value="0" /></label>
                    <label>y max: <input id="yMax" type="number" min="0" max="1" step="0.001" value="1" /></label>
                    <label>Color: 
                        <select id="colorMode">
                            <option value="hue" selected>Hue by r</option>
                            <option value="mono">Monochrome</option>
                        </select>
                    </label>
                    <button class="button" id="bifPause">Pause</button>
                    <button class="button secondary" id="bifRestart">Restart</button>
                    <button class="button secondary" id="resetAll">Reset</button>
                </div>
            <canvas id="bif" width="1000" height="700"></canvas>
            <div class="caption">For each r, iterate x ← r x (1 − x), discard transients, then plot the long‑term x values. Period‑doubling leads to chaos as r increases.</div>
            <p style="font-size:.95rem; color:#4a4a4a; margin-top:6px;">
                Bifurcation diagram: Each vertical slice corresponds to a single r. After skipping transient iterations, the remaining iterates reveal the attractor: a single point (fixed point), two points (period‑2), four points, and so on, accumulating into a fractal set of bands — the onset of chaos.
            </p>
            </div>

            <div class="panel tabview" id="panel-lyap">
                <h3 style="margin:6px 0 8px 0">Lyapunov Exponent λ(r)</h3>
                <div class="controls">
                    <label>r min: <input id="lrMin" type="number" min="2.5" max="4" step="0.001" value="2.5" /></label>
                    <label>r max: <input id="lrMax" type="number" min="2.5" max="4" step="0.001" value="4" /></label>
                    <label>Samples: <input id="lsamples" type="number" min="200" max="4000" step="50" value="1000" /></label>
                    <label>Skip: <input id="lskip" type="number" min="50" max="5000" step="50" value="300" /></label>
                    <label>Iter: <input id="lN" type="number" min="50" max="8000" step="50" value="1000" /></label>
                    <label>y min: <input id="lyMin" type="number" step="0.1" value="-2.0" /></label>
                    <label>y max: <input id="lyMax" type="number" step="0.1" value="1.0" /></label>
                    <button class="button" id="lyPause">Pause</button>
                    <button class="button secondary" id="lyRestart">Restart</button>
                </div>
                <canvas id="lyap" width="1000" height="700"></canvas>
                <div class="caption">λ(r) ≈ (1/N) ∑ log |f’(xₙ)| after skipping transients; f’(x)=r(1−2x). Positive λ indicates chaos.</div>
            </div>
        </div>
        </div>

        <div class="note-bubble note-right">Side notes — windows of periodicity, Feigenbaum constants.</div>

        <div class="note-bubble note-bottom">Bottom notes — takeaways and further reading.</div>
    </div>

    <a class="back" href="../index.html">← Back to Introduction</a>

    <script>
    function logistic(x, r){ return r * x * (1 - x); }

    function drawCobweb() {
        const canvas = document.getElementById('cobweb');
        const ctx = canvas.getContext('2d');
        const r = parseFloat(document.getElementById('r').value);
        const iters = parseInt(document.getElementById('iters').value, 10);
        let x = parseFloat(document.getElementById('x0').value);

        // Clear
        ctx.clearRect(0,0,canvas.width, canvas.height);

        // Axes box + subtle grid
        ctx.strokeStyle = '#a8a8a8';
        ctx.lineWidth = 1;
        ctx.strokeRect(40, 20, canvas.width-60, canvas.height-60);

        // Helpers
        const toX = v => 40 + v * (canvas.width - 60);
        const toY = v => 20 + (1 - v) * (canvas.height - 60);

        // Grid lines
        ctx.setLineDash([4,6]);
        ctx.strokeStyle = '#e6e6e6';
        [0.25,0.5,0.75].forEach(t=>{
            ctx.beginPath(); ctx.moveTo(toX(0), toY(t)); ctx.lineTo(toX(1), toY(t)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toX(t), toY(0)); ctx.lineTo(toX(t), toY(1)); ctx.stroke();
        });
        ctx.setLineDash([]);

        // y = x
        ctx.strokeStyle = '#c0c0c0';
        ctx.beginPath();
        ctx.moveTo(toX(0), toY(0));
        ctx.lineTo(toX(1), toY(1));
        ctx.stroke();

        // y = r x (1 - x)
        ctx.strokeStyle = '#0557b6';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0;i<=500;i++){
            const xv = i/500;
            const yv = Math.max(0, Math.min(1, logistic(xv, r)));
            const px = toX(xv), py = toY(yv);
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.stroke();

        // Cobweb iterations
        ctx.strokeStyle = 'rgba(239,68,68,0.9)';
        ctx.fillStyle = '#ef4444';
        ctx.lineWidth = 1.2;
        let xn = x;
        // draw starting point
        ctx.beginPath(); ctx.arc(toX(xn), toY(0), 3, 0, Math.PI*2); ctx.fill();

        for(let n=0;n<iters;n++){
            const yn = logistic(xn, r);
            // vertical: (xn, xn) -> (xn, yn) using y=x reflection
            ctx.beginPath(); ctx.moveTo(toX(xn), toY(xn)); ctx.lineTo(toX(xn), toY(yn)); ctx.stroke();

            // horizontal: (xn, yn) -> (yn, yn)
            ctx.beginPath(); ctx.moveTo(toX(xn), toY(yn)); ctx.lineTo(toX(yn), toY(yn)); ctx.stroke();

            xn = yn;
            if(xn<0 || xn>1) break;
        }
    }

    // Progressive bifurcation renderer
    let bifRunning = true;
    let bifVersion = 0; // increments on restart to cancel prior runs
    function startBifurcation(){
        const canvas = document.getElementById('bif');
        const ctx = canvas.getContext('2d');
        const rMin = parseFloat(document.getElementById('rMin').value);
        const rMax = parseFloat(document.getElementById('rMax').value);
        const samples = parseInt(document.getElementById('samples').value, 10);
        const skip = parseInt(document.getElementById('skip').value, 10);
        const plotN = parseInt(document.getElementById('plotN').value, 10);
        const yMin = Math.max(0, Math.min(1, parseFloat(document.getElementById('yMin').value)));
        const yMax = Math.max(0, Math.min(1, parseFloat(document.getElementById('yMax').value)));
        const colorMode = document.getElementById('colorMode').value;

        const localVersion = ++bifVersion;
        ctx.clearRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#111';

        const toX = r => ( (r - rMin) / (rMax - rMin) ) * (canvas.width-40) + 20;
        const toY = x => {
            const y = (x - yMin) / (yMax - yMin);
            const yc = Math.max(0, Math.min(1, y));
            return (1 - yc) * (canvas.height-40) + 20;
        };

        const rStep = (rMax - rMin) / samples;
        let i = 0;
        const chunk = Math.max(2, Math.floor(samples/120)); // ~120 frames

        function frame(){
            if(localVersion !== bifVersion) return; // canceled
            if(!bifRunning){ requestAnimationFrame(frame); return; }

            const iEnd = Math.min(samples, i + chunk);
            for(; i <= iEnd; i++){
                const r = rMin + i * rStep;
                let x = 0.5;
                for(let t=0;t<skip;t++) x = logistic(x, r);
                // color for this r column
                if(colorMode === 'hue'){
                    const hue = 240 * (i / Math.max(1,samples));
                    ctx.fillStyle = `hsl(${hue}, 80%, 35%)`;
                } else {
                    ctx.fillStyle = '#111';
                }
                for(let t=0;t<plotN;t++){
                    x = logistic(x, r);
                    const px = toX(r);
                    const py = toY(x);
                    ctx.fillRect(px, py, 1, 1);
                }
            }
            if(i <= samples){
                requestAnimationFrame(frame);
            }
        }
        requestAnimationFrame(frame);
    }

    // Lyapunov λ(r) progressive renderer
    let lyRunning = true;
    let lyVersion = 0;
    function startLyapunov(){
        const canvas = document.getElementById('lyap');
        const ctx = canvas.getContext('2d');
        const rMin = parseFloat(document.getElementById('lrMin').value);
        const rMax = parseFloat(document.getElementById('lrMax').value);
        const samples = parseInt(document.getElementById('lsamples').value, 10);
        const skip = parseInt(document.getElementById('lskip').value, 10);
        const N = parseInt(document.getElementById('lN').value, 10);
        const yMin = parseFloat(document.getElementById('lyMin').value);
        const yMax = parseFloat(document.getElementById('lyMax').value);

        const localVersion = ++lyVersion;
        ctx.clearRect(0,0,canvas.width, canvas.height);
        // axes
        ctx.strokeStyle = '#a8a8a8'; ctx.strokeRect(40,20,canvas.width-60,canvas.height-60);
        const toX = r => ((r - rMin)/(rMax - rMin))*(canvas.width-60) + 40;
        const toY = l => {
            const y = (l - yMin)/(yMax - yMin);
            const yc = Math.max(0, Math.min(1,y));
            return (1-yc)*(canvas.height-60)+20;
        };
        // zero line
        if(yMin < 0 && yMax > 0){
            ctx.strokeStyle = '#e5e7eb'; ctx.setLineDash([4,6]);
            const y0 = toY(0); ctx.beginPath(); ctx.moveTo(40,y0); ctx.lineTo(canvas.width-20,y0); ctx.stroke();
            ctx.setLineDash([]);
        }

        const rStep = (rMax - rMin)/samples;
        let i = 0;
        const chunk = Math.max(2, Math.floor(samples/120));

        function frame(){
            if(localVersion !== lyVersion) return;
            if(!lyRunning){ requestAnimationFrame(frame); return; }

            const iEnd = Math.min(samples, i+chunk);
            ctx.lineWidth = 1.4; ctx.strokeStyle = '#0366d6';
            ctx.beginPath();
            for(; i<=iEnd; i++){
                const r = rMin + i*rStep;
                let x = 0.5;
                for(let t=0;t<skip;t++) x = logistic(x,r);
                let sum = 0;
                for(let t=0;t<N;t++){
                    const d = Math.abs(r*(1 - 2*x));
                    sum += Math.log(d+1e-12);
                    x = logistic(x,r);
                }
                const lam = sum/N;
                const px = toX(r), py = toY(lam);
                if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
            }
            ctx.stroke();
            if(i<=samples) requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
    }

    function bindControls(){
        const r = document.getElementById('r');
        const rNum = document.getElementById('rNum');
        const x0 = document.getElementById('x0');
        const x0Num = document.getElementById('x0Num');
        const iters = document.getElementById('iters');
        const sync = (a,b) => { a.addEventListener('input', ()=>{ b.value=a.value; drawCobweb(); }); };
        sync(r, rNum); sync(rNum, r);
        sync(x0, x0Num); sync(x0Num, x0);
        iters.addEventListener('input', drawCobweb);
        document.getElementById('randomize').addEventListener('click', ()=>{
            const v = Math.random();
            x0.value = v.toFixed(3); x0Num.value = v.toFixed(3); drawCobweb();
        });
        document.getElementById('clearCobweb').addEventListener('click', drawCobweb);
        // Bifurcation controls: live update with progressive draw
        const onBifChange = () => startBifurcation();
        ['rMin','rMax','samples','skip','plotN'].forEach(id => {
            document.getElementById(id).addEventListener('input', onBifChange);
            document.getElementById(id).addEventListener('change', onBifChange);
        });
        const pauseBtn = document.getElementById('bifPause');
        const restartBtn = document.getElementById('bifRestart');
        pauseBtn.addEventListener('click', ()=>{
            bifRunning = !bifRunning;
            pauseBtn.textContent = bifRunning ? 'Pause' : 'Resume';
        });
        restartBtn.addEventListener('click', ()=>{
            bifRunning = true;
            pauseBtn.textContent = 'Pause';
            startBifurcation();
        });
        // Lyapunov controls
        const lyPause = document.getElementById('lyPause');
        const lyRestart = document.getElementById('lyRestart');
        if(lyPause && lyRestart){
            lyPause.addEventListener('click', ()=>{
                lyRunning = !lyRunning;
                lyPause.textContent = lyRunning ? 'Pause' : 'Resume';
            });
            const onLyChange = ()=> startLyapunov();
            ;['lrMin','lrMax','lsamples','lskip','lN','lyMin','lyMax'].forEach(id=>{
                const el = document.getElementById(id); if(el){ el.addEventListener('input', onLyChange); el.addEventListener('change', onLyChange); }
            });
            lyRestart.addEventListener('click', ()=>{ lyRunning = true; lyPause.textContent = 'Pause'; startLyapunov(); });
        }
        // Tabs
        document.querySelectorAll('.tabbtn').forEach(btn=>{
            btn.addEventListener('click', ()=>{
                document.querySelectorAll('.tabbtn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                const target = btn.getAttribute('data-target');
                document.querySelectorAll('.tabview').forEach(p=>p.classList.remove('active'));
                const panel = document.getElementById(target);
                if(panel){ panel.classList.add('active'); }
            });
        });
        // Reset all controls to default values
        document.getElementById('resetAll').addEventListener('click', ()=>{
            // Cobweb defaults
            r.value = 3.5; rNum.value = 3.5;
            x0.value = 0.2; x0Num.value = 0.2;
            iters.value = 60;
            // Bifurcation defaults
            document.getElementById('rMin').value = 2.5;
            document.getElementById('rMax').value = 4.0;
            document.getElementById('samples').value = 1000;
            document.getElementById('skip').value = 300;
            document.getElementById('plotN').value = 300;
            document.getElementById('yMin').value = 0.0;
            document.getElementById('yMax').value = 1.0;
            document.getElementById('colorMode').value = 'hue';
            drawCobweb();
            startBifurcation();
        });
    }

    // Initial render
    window.addEventListener('DOMContentLoaded', ()=>{
        bindControls();
        drawCobweb();
        // Kick off progressive draws
        setTimeout(startBifurcation, 50);
        setTimeout(startLyapunov, 100);
    });
    </script>
</body>
</html>
